{"ast":null,"code":"import _createForOfIteratorHelper from\"D:/maze-solver-main/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import{dijkstra}from\"./dijkstra\";import{dfs}from\"./dfs\";import{bfs}from\"./bfs\";import{astar}from\"./astar\";export{dijkstra,dfs,bfs,astar,getNodesInShortestPathOrder,getAllNodes,sortNodesByDistance,getUnvisitedNeighbours};/*----------------------------------------------------common helper functions----------------------------------------------------*/ // returns an array of nodes from the grid\nfunction getAllNodes(grid){var nodes=[];var _iterator=_createForOfIteratorHelper(grid),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var row=_step.value;var _iterator2=_createForOfIteratorHelper(row),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;nodes.push(node);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return nodes;}// sorts the nodes by distance\nfunction sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.distance-nodeB.distance;});}// returns an array of unvisited neighbours of the node\nfunction getUnvisitedNeighbours(node,grid){var neighbours=[];var row=node.row,col=node.col;if(row>0)neighbours.push(grid[row-1][col]);if(row<grid.length-1)neighbours.push(grid[row+1][col]);if(col>0)neighbours.push(grid[row][col-1]);if(col<grid[0].length-1)neighbours.push(grid[row][col+1]);return neighbours.filter(function(neighbor){return!neighbor.isVisited;});}// backtracks from the finishNode to find the shortest path\n// only works when called *after* the algorithm function is executed\nfunction getNodesInShortestPathOrder(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"names":["dijkstra","dfs","bfs","astar","getNodesInShortestPathOrder","getAllNodes","sortNodesByDistance","getUnvisitedNeighbours","grid","nodes","row","node","push","unvisitedNodes","sort","nodeA","nodeB","distance","neighbours","col","length","filter","neighbor","isVisited","finishNode","nodesInShortestPathOrder","currentNode","unshift","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/index.js"],"sourcesContent":["import { dijkstra } from \"./dijkstra\";\nimport { dfs } from \"./dfs\";\nimport { bfs } from \"./bfs\";\nimport { astar } from \"./astar\";\n\nexport { dijkstra, dfs, bfs, astar, getNodesInShortestPathOrder, getAllNodes, sortNodesByDistance, getUnvisitedNeighbours };\n\n/*----------------------------------------------------common helper functions----------------------------------------------------*/\n// returns an array of nodes from the grid\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// sorts the nodes by distance\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\n// returns an array of unvisited neighbours of the node\nfunction getUnvisitedNeighbours(node, grid) {\n  const neighbours = [];\n  const { row, col } = node;\n  if (row > 0)\n    neighbours.push(grid[row - 1][col]);\n  if (row < grid.length - 1)\n    neighbours.push(grid[row + 1][col]);\n  if (col > 0)\n    neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1)\n    neighbours.push(grid[row][col + 1]);\n  return neighbours.filter(neighbor => !neighbor.isVisited);\n}\n  \n// backtracks from the finishNode to find the shortest path\n// only works when called *after* the algorithm function is executed\nfunction getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}"],"mappings":"iIAAA,OAASA,QAAT,KAAyB,YAAzB,CACA,OAASC,GAAT,KAAoB,OAApB,CACA,OAASC,GAAT,KAAoB,OAApB,CACA,OAASC,KAAT,KAAsB,SAAtB,CAEA,OAASH,QAAT,CAAmBC,GAAnB,CAAwBC,GAAxB,CAA6BC,KAA7B,CAAoCC,2BAApC,CAAiEC,WAAjE,CAA8EC,mBAA9E,CAAmGC,sBAAnG,EAEA,mI,CACA;AACA,QAASF,YAAT,CAAqBG,IAArB,CAA2B,CACzB,GAAMC,MAAK,CAAG,EAAd,CADyB,yCAEPD,IAFO,YAEzB,+CAAwB,IAAbE,IAAa,uDACHA,GADG,aACtB,kDAAwB,IAAbC,KAAa,cACtBF,KAAK,CAACG,IAAN,CAAWD,IAAX,EACD,CAHqB,uDAIvB,CANwB,qDAOzB,MAAOF,MAAP,CACD,CAED;AACA,QAASH,oBAAT,CAA6BO,cAA7B,CAA6C,CAC3CA,cAAc,CAACC,IAAf,CAAoB,SAACC,KAAD,CAAQC,KAAR,QAAkBD,MAAK,CAACE,QAAN,CAAiBD,KAAK,CAACC,QAAzC,EAApB,EACD,CAED;AACA,QAASV,uBAAT,CAAgCI,IAAhC,CAAsCH,IAAtC,CAA4C,CAC1C,GAAMU,WAAU,CAAG,EAAnB,CACA,GAAQR,IAAR,CAAqBC,IAArB,CAAQD,GAAR,CAAaS,GAAb,CAAqBR,IAArB,CAAaQ,GAAb,CACA,GAAIT,GAAG,CAAG,CAAV,CACEQ,UAAU,CAACN,IAAX,CAAgBJ,IAAI,CAACE,GAAG,CAAG,CAAP,CAAJ,CAAcS,GAAd,CAAhB,EACF,GAAIT,GAAG,CAAGF,IAAI,CAACY,MAAL,CAAc,CAAxB,CACEF,UAAU,CAACN,IAAX,CAAgBJ,IAAI,CAACE,GAAG,CAAG,CAAP,CAAJ,CAAcS,GAAd,CAAhB,EACF,GAAIA,GAAG,CAAG,CAAV,CACED,UAAU,CAACN,IAAX,CAAgBJ,IAAI,CAACE,GAAD,CAAJ,CAAUS,GAAG,CAAG,CAAhB,CAAhB,EACF,GAAIA,GAAG,CAAGX,IAAI,CAAC,CAAD,CAAJ,CAAQY,MAAR,CAAiB,CAA3B,CACEF,UAAU,CAACN,IAAX,CAAgBJ,IAAI,CAACE,GAAD,CAAJ,CAAUS,GAAG,CAAG,CAAhB,CAAhB,EACF,MAAOD,WAAU,CAACG,MAAX,CAAkB,SAAAC,QAAQ,QAAI,CAACA,QAAQ,CAACC,SAAd,EAA1B,CAAP,CACD,CAED;AACA;AACA,QAASnB,4BAAT,CAAqCoB,UAArC,CAAiD,CAC/C,GAAMC,yBAAwB,CAAG,EAAjC,CACA,GAAIC,YAAW,CAAGF,UAAlB,CACA,MAAOE,WAAW,GAAK,IAAvB,CAA6B,CAC3BD,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC,EACAA,WAAW,CAAGA,WAAW,CAACE,YAA1B,CACD,CACD,MAAOH,yBAAP,CACD"},"metadata":{},"sourceType":"module"}