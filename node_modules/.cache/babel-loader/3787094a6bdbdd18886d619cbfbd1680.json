{"ast":null,"code":"let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  // if start or finish node skip it\n  if (!startNode || !finishNode) return; // arrays with values of grid dimensions\n\n  let vertical = Array(grid[0].length).fill().map((_, i) => i);\n  let horizontal = Array(grid.length).fill().map((_, i) => i); // initializing the walls global variable to an empty array\n\n  walls = []; // main func\n\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n} // main func \n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) return;\n  let dir;\n  let num;\n\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  } // recursive part where the approach to \n  // start horizontal or vertical is dependent on dir variable\n\n\n  if (dir === 0) {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  } else {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n} // generates a random number which is odd\n\n\nfunction generateOddRandomNumber(arr) {\n  let max = arr.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2));\n\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) randomNum -= 1;else randomNum += 1;\n  }\n\n  return arr[randomNum];\n} // func to push the coordinates of nodes into wall array\n\n\nfunction addWalls(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n\n    for (let temp of horizontal) {\n      if (temp === startNode.row && num === startNode.col || temp === finishNode.row && num === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n\n    for (let temp of vertical) {\n      if (num === startNode.row && temp === startNode.col || num === finishNode.row && temp === finishNode.col) {\n        isStartFinish = true;\n        continue;\n      }\n\n      tempWalls.push([num, temp]);\n    }\n  }\n\n  if (!isStartFinish) {\n    let rand = generateRandomNumber(tempWalls.length);\n    tempWalls = [...tempWalls.slice(0, rand), ...tempWalls.slice(rand + 1)];\n  }\n\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n} // func to generate a random number for the generation of walls in tempWalls\n// within the range of tempWalls arr length\n\n\nfunction generateRandomNumber(maxValue) {\n  let randomNum = Math.floor(Math.random() * (maxValue / 2));\n\n  if (randomNum % 2 !== 0) {\n    if (randomNum === maxValue) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n\n  return randomNum;\n}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","Array","length","fill","map","_","i","horizontal","getRecursiveWalls","dir","num","generateOddRandomNumber","addWalls","slice","indexOf","arr","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","push","rand","generateRandomNumber","wall","maxValue"],"sources":["D:/maze-solver-main/src/maze-algorithms/recursiveDivision.js"],"sourcesContent":["let walls;\n\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  // if start or finish node skip it\n  if (!startNode || !finishNode)\n    return;\n  // arrays with values of grid dimensions\n  let vertical = Array(grid[0].length).fill().map((_, i) => i);\n  let horizontal = Array(grid.length).fill().map((_, i) => i);\n  // initializing the walls global variable to an empty array\n  walls = [];\n  // main func\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\n// main func \nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2)\n    return;\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  // recursive part where the approach to \n  // start horizontal or vertical is dependent on dir variable\n  if (dir === 0) {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  }\n  else {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\n\n// generates a random number which is odd\nfunction generateOddRandomNumber(arr) {\n  let max = arr.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)); \n  if (randomNum % 2 === 0) {\n    if (randomNum === max)\n      randomNum -= 1;\n    else\n      randomNum += 1;\n  }\n  return arr[randomNum];\n} \n\n// func to push the coordinates of nodes into wall array\nfunction addWalls(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2)\n      return;\n    for (let temp of horizontal) {\n      if ((temp === startNode.row && num === startNode.col) ||(temp === finishNode.row && num === finishNode.col)) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  }\n  else {\n    if (vertical.length === 2)\n      return;\n    for (let temp of vertical) {\n      if ((num === startNode.row && temp === startNode.col) ||(num === finishNode.row && temp === finishNode.col)) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    let rand = generateRandomNumber(tempWalls.length);\n    tempWalls= [...tempWalls.slice(0, rand), ...tempWalls.slice(rand + 1)];\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\n// func to generate a random number for the generation of walls in tempWalls\n// within the range of tempWalls arr length\nfunction generateRandomNumber(maxValue) {\n  let randomNum = Math.floor(Math.random() * (maxValue / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === maxValue) {\n      randomNum -= 1;\n    }\n    else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}