{"ast":null,"code":"// Performs BFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid,startNode,finishNode){var visitedNodesInOrder=[];// queue to keep track of the visited nodes\nvar queue=[];queue.push(startNode);while(queue.length){var currNode=queue.shift();// if the finsih node is reached then we return the visitedNodes array\nif(currNode===finishNode)return visitedNodesInOrder;// we skip the nodes which are walls, start node or finish node\nif(!currNode.isWall&&(currNode.isStart||!currNode.isVisited)){currNode.isVisited=true;visitedNodesInOrder.push(currNode);var row=currNode.row,col=currNode.col;updateUnvisitedNeighbours(row,col,queue,grid,currNode);}}}// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row,col,queue,grid,currNode){var next;if(row>0){next=grid[row-1][col];if(!next.isVisited){queue.push(next);next.previousNode=currNode;}}if(row<grid.length-1){next=grid[row+1][col];if(!next.isVisited){queue.push(next);next.previousNode=currNode;}}if(col>0){next=grid[row][col-1];if(!next.isVisited){queue.push(next);next.previousNode=currNode;}}if(col<grid[0].length-1){next=grid[row][col+1];if(!next.isVisited){queue.push(next);next.previousNode=currNode;}}}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","queue","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/bfs.js"],"sourcesContent":["// Performs BFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  // queue to keep track of the visited nodes\n  let queue = [];\n  queue.push(startNode);\n  while (queue.length) {\n    const currNode = queue.shift();\n    // if the finsih node is reached then we return the visitedNodes array\n    if (currNode === finishNode)\n      return visitedNodesInOrder;\n    \n    // we skip the nodes which are walls, start node or finish node\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const { row, col } = currNode;\n      updateUnvisitedNeighbours(row, col, queue, grid,currNode);\n    }\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row,col,queue,grid,currNode) {\n      let next;\n      if (row > 0) {\n        next = grid[row - 1][col];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (row < grid.length - 1) {\n        next = grid[row + 1][col];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (col > 0) {\n        next = grid[row][col - 1];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (col < grid[0].length - 1) {\n        next = grid[row][col + 1];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,MAAO,SAASA,IAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,oBAAmB,CAAG,EAA5B,CACA;AACA,GAAIC,MAAK,CAAG,EAAZ,CACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX,EACA,MAAOG,KAAK,CAACE,MAAb,CAAqB,CACnB,GAAMC,SAAQ,CAAGH,KAAK,CAACI,KAAN,EAAjB,CACA;AACA,GAAID,QAAQ,GAAKL,UAAjB,CACE,MAAOC,oBAAP,CAEF;AACA,GAAI,CAACI,QAAQ,CAACE,MAAV,GAAqBF,QAAQ,CAACG,OAAT,EAAoB,CAACH,QAAQ,CAACI,SAAnD,CAAJ,CAAmE,CACjEJ,QAAQ,CAACI,SAAT,CAAqB,IAArB,CACAR,mBAAmB,CAACE,IAApB,CAAyBE,QAAzB,EACA,GAAQK,IAAR,CAAqBL,QAArB,CAAQK,GAAR,CAAaC,GAAb,CAAqBN,QAArB,CAAaM,GAAb,CACAC,yBAAyB,CAACF,GAAD,CAAMC,GAAN,CAAWT,KAAX,CAAkBJ,IAAlB,CAAuBO,QAAvB,CAAzB,CACD,CACF,CACF,CAED;AACA;AACA,QAASO,0BAAT,CAAmCF,GAAnC,CAAuCC,GAAvC,CAA2CT,KAA3C,CAAiDJ,IAAjD,CAAsDO,QAAtD,CAAgE,CAC1D,GAAIQ,KAAJ,CACA,GAAIH,GAAG,CAAG,CAAV,CAAa,CACXG,IAAI,CAAGf,IAAI,CAACY,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX,EACAA,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACD,CACF,CACD,GAAIK,GAAG,CAAGZ,IAAI,CAACM,MAAL,CAAc,CAAxB,CAA2B,CACzBS,IAAI,CAAGf,IAAI,CAACY,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX,EACAA,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACD,CACF,CACD,GAAIM,GAAG,CAAG,CAAV,CAAa,CACXE,IAAI,CAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX,EACAA,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACD,CACF,CACD,GAAIM,GAAG,CAAGb,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,CAAiB,CAA3B,CAA8B,CAC5BS,IAAI,CAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX,EACAA,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACD,CACF,CACN"},"metadata":{},"sourceType":"module"}