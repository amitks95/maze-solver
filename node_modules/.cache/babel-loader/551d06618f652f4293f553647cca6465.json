{"ast":null,"code":"// Performs DFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid,startNode,finishNode){var visitedNodesInOrder=[];// stack to keep track of the visited nodes\nvar stack=[];stack.push(startNode);while(stack.length){var currNode=stack.pop();// if the finsih node is reached then we return the visitedNodes array\nif(currNode===finishNode)return visitedNodesInOrder;// we skip the nodes which are walls, start node or finish node\nif(!currNode.isWall&&(currNode.isStart||!currNode.isVisited)){currNode.isVisited=true;visitedNodesInOrder.push(currNode);var row=currNode.row,col=currNode.col;updateUnvisitedNeighbours(row,col,stack,grid,currNode);}}}// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row,col,stack,grid,currNode){var next;if(row>0){next=grid[row-1][col];if(!next.isVisited){next.previousNode=currNode;stack.push(next);}}if(row<grid.length-1){next=grid[row+1][col];if(!next.isVisited){next.previousNode=currNode;stack.push(next);}}if(col<grid[0].length-1){next=grid[row][col+1];if(!next.isVisited){next.previousNode=currNode;stack.push(next);}}if(col>0){next=grid[row][col-1];if(!next.isVisited){next.previousNode=currNode;stack.push(next);}}}","map":{"version":3,"names":["dfs","grid","startNode","finishNode","visitedNodesInOrder","stack","push","length","currNode","pop","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/dfs.js"],"sourcesContent":["// Performs DFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  // stack to keep track of the visited nodes\n  const stack = []; \n  stack.push(startNode);\n  while (stack.length) {\n    const currNode = stack.pop();\n    // if the finsih node is reached then we return the visitedNodes array\n    if (currNode === finishNode) \n      return visitedNodesInOrder;\n\n    // we skip the nodes which are walls, start node or finish node\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const { row, col } = currNode;\n      updateUnvisitedNeighbours(row, col, stack, grid,currNode);\n    }\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction  updateUnvisitedNeighbours(row, col, stack, grid,currNode) {\n      let next;\n      if (row > 0) {\n        next = grid[row - 1][col];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (row < grid.length - 1) {\n        next = grid[row + 1][col];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        next = grid[row][col + 1];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (col > 0) {\n        next = grid[row][col - 1];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,MAAO,SAASA,IAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,oBAAmB,CAAG,EAA5B,CACA;AACA,GAAMC,MAAK,CAAG,EAAd,CACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX,EACA,MAAOG,KAAK,CAACE,MAAb,CAAqB,CACnB,GAAMC,SAAQ,CAAGH,KAAK,CAACI,GAAN,EAAjB,CACA;AACA,GAAID,QAAQ,GAAKL,UAAjB,CACE,MAAOC,oBAAP,CAEF;AACA,GAAI,CAACI,QAAQ,CAACE,MAAV,GAAqBF,QAAQ,CAACG,OAAT,EAAoB,CAACH,QAAQ,CAACI,SAAnD,CAAJ,CAAmE,CACjEJ,QAAQ,CAACI,SAAT,CAAqB,IAArB,CACAR,mBAAmB,CAACE,IAApB,CAAyBE,QAAzB,EACA,GAAQK,IAAR,CAAqBL,QAArB,CAAQK,GAAR,CAAaC,GAAb,CAAqBN,QAArB,CAAaM,GAAb,CACAC,yBAAyB,CAACF,GAAD,CAAMC,GAAN,CAAWT,KAAX,CAAkBJ,IAAlB,CAAuBO,QAAvB,CAAzB,CACD,CACF,CACF,CAED;AACA;AACA,QAAUO,0BAAV,CAAoCF,GAApC,CAAyCC,GAAzC,CAA8CT,KAA9C,CAAqDJ,IAArD,CAA0DO,QAA1D,CAAoE,CAC9D,GAAIQ,KAAJ,CACA,GAAIH,GAAG,CAAG,CAAV,CAAa,CACXG,IAAI,CAAGf,IAAI,CAACY,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBI,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACAH,KAAK,CAACC,IAAN,CAAWU,IAAX,EACD,CACF,CACD,GAAIH,GAAG,CAAGZ,IAAI,CAACM,MAAL,CAAc,CAAxB,CAA2B,CACzBS,IAAI,CAAGf,IAAI,CAACY,GAAG,CAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBI,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACAH,KAAK,CAACC,IAAN,CAAWU,IAAX,EACD,CACF,CACD,GAAIF,GAAG,CAAGb,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,CAAiB,CAA3B,CAA8B,CAC5BS,IAAI,CAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBI,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACAH,KAAK,CAACC,IAAN,CAAWU,IAAX,EACD,CACF,CACD,GAAIF,GAAG,CAAG,CAAV,CAAa,CACXE,IAAI,CAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,CAAG,CAAhB,CAAP,CACA,GAAI,CAACE,IAAI,CAACJ,SAAV,CAAqB,CACnBI,IAAI,CAACC,YAAL,CAAoBT,QAApB,CACAH,KAAK,CAACC,IAAN,CAAWU,IAAX,EACD,CACF,CACN"},"metadata":{},"sourceType":"module"}