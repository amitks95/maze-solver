{"ast":null,"code":"import _toConsumableArray from\"D:/maze-solver-main/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"D:/maze-solver-main/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";var walls;export function recursiveDivisionMaze(grid,startNode,finishNode){// if start or finish node skip it\nif(!startNode||!finishNode)return;// arrays with values of grid dimensions\nvar vertical=Array(grid[0].length).fill().map(function(_,i){return i;});var horizontal=Array(grid.length).fill().map(function(_,i){return i;});// initializing the walls global variable to an empty array\nwalls=[];// main func\ngetRecursiveWalls(vertical,horizontal,grid,startNode,finishNode);return walls;}// main func \nfunction getRecursiveWalls(vertical,horizontal,grid,startNode,finishNode){if(vertical.length<2||horizontal.length<2)return;var dir;var num;if(vertical.length>horizontal.length){dir=0;num=generateOddRandomNumber(vertical);}if(vertical.length<=horizontal.length){dir=1;num=generateOddRandomNumber(horizontal);}// recursive part where the approach to \n// start horizontal or vertical is dependent on dir variable\nif(dir===0){addWalls(dir,num,vertical,horizontal,startNode,finishNode);getRecursiveWalls(vertical.slice(0,vertical.indexOf(num)),horizontal,grid,startNode,finishNode);getRecursiveWalls(vertical.slice(vertical.indexOf(num)+1),horizontal,grid,startNode,finishNode);}else{addWalls(dir,num,vertical,horizontal,startNode,finishNode);getRecursiveWalls(vertical,horizontal.slice(0,horizontal.indexOf(num)),grid,startNode,finishNode);getRecursiveWalls(vertical,horizontal.slice(horizontal.indexOf(num)+1),grid,startNode,finishNode);}}// generates a random number which is odd\nfunction generateOddRandomNumber(arr){var max=arr.length-1;var randomNum=Math.floor(Math.random()*(max/2));if(randomNum%2===0){if(randomNum===max)randomNum-=1;else randomNum+=1;}return arr[randomNum];}// func to push the coordinates of nodes into wall array\nfunction addWalls(dir,num,vertical,horizontal,startNode,finishNode){var isStartFinish=false;var tempWalls=[];if(dir===0){if(horizontal.length===2)return;var _iterator=_createForOfIteratorHelper(horizontal),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var temp=_step.value;if(temp===startNode.row&&num===startNode.col||temp===finishNode.row&&num===finishNode.col){isStartFinish=true;continue;}tempWalls.push([temp,num]);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{if(vertical.length===2)return;var _iterator2=_createForOfIteratorHelper(vertical),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _temp=_step2.value;if(num===startNode.row&&_temp===startNode.col||num===finishNode.row&&_temp===finishNode.col){isStartFinish=true;continue;}tempWalls.push([num,_temp]);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}if(!isStartFinish){var rand=generateRandomNumber(tempWalls.length);tempWalls=[].concat(_toConsumableArray(tempWalls.slice(0,rand)),_toConsumableArray(tempWalls.slice(rand+1)));}var _iterator3=_createForOfIteratorHelper(tempWalls),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var wall=_step3.value;walls.push(wall);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}}// func to generate a random number for the generation of walls in tempWalls\n// within the range of tempWalls arr length\nfunction generateRandomNumber(maxValue){var randomNum=Math.floor(Math.random()*(maxValue/2));if(randomNum%2!==0){if(randomNum===maxValue){randomNum-=1;}else{randomNum+=1;}}return randomNum;}","map":{"version":3,"names":["walls","recursiveDivisionMaze","grid","startNode","finishNode","vertical","Array","length","fill","map","_","i","horizontal","getRecursiveWalls","dir","num","generateOddRandomNumber","addWalls","slice","indexOf","arr","max","randomNum","Math","floor","random","isStartFinish","tempWalls","temp","row","col","push","rand","generateRandomNumber","wall","maxValue"],"sources":["D:/maze-solver-main/src/maze-algorithms/recursiveDivision.js"],"sourcesContent":["let walls;\n\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  // if start or finish node skip it\n  if (!startNode || !finishNode)\n    return;\n  // arrays with values of grid dimensions\n  let vertical = Array(grid[0].length).fill().map((_, i) => i);\n  let horizontal = Array(grid.length).fill().map((_, i) => i);\n  // initializing the walls global variable to an empty array\n  walls = [];\n  // main func\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\n// main func \nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2)\n    return;\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  // recursive part where the approach to \n  // start horizontal or vertical is dependent on dir variable\n  if (dir === 0) {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(0, vertical.indexOf(num)), horizontal, grid, startNode, finishNode);\n    getRecursiveWalls(vertical.slice(vertical.indexOf(num) + 1), horizontal, grid, startNode, finishNode);\n  }\n  else {\n    addWalls(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(0, horizontal.indexOf(num)), grid, startNode, finishNode);\n    getRecursiveWalls(vertical, horizontal.slice(horizontal.indexOf(num) + 1), grid, startNode, finishNode);\n  }\n}\n\n// generates a random number which is odd\nfunction generateOddRandomNumber(arr) {\n  let max = arr.length - 1;\n  let randomNum = Math.floor(Math.random() * (max / 2)); \n  if (randomNum % 2 === 0) {\n    if (randomNum === max)\n      randomNum -= 1;\n    else\n      randomNum += 1;\n  }\n  return arr[randomNum];\n} \n\n// func to push the coordinates of nodes into wall array\nfunction addWalls(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2)\n      return;\n    for (let temp of horizontal) {\n      if ((temp === startNode.row && num === startNode.col) ||(temp === finishNode.row && num === finishNode.col)) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  }\n  else {\n    if (vertical.length === 2)\n      return;\n    for (let temp of vertical) {\n      if ((num === startNode.row && temp === startNode.col) ||(num === finishNode.row && temp === finishNode.col)) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    let rand = generateRandomNumber(tempWalls.length);\n    tempWalls= [...tempWalls.slice(0, rand), ...tempWalls.slice(rand + 1)];\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\n// func to generate a random number for the generation of walls in tempWalls\n// within the range of tempWalls arr length\nfunction generateRandomNumber(maxValue) {\n  let randomNum = Math.floor(Math.random() * (maxValue / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === maxValue) {\n      randomNum -= 1;\n    }\n    else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}