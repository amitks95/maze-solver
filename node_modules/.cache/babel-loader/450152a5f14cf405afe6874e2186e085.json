{"ast":null,"code":"import _createForOfIteratorHelper from\"D:/maze-solver-main/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nimport{getAllNodes,sortNodesByDistance,getUnvisitedNeighbours}from\"./index\";export function dijkstra(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;var unvisitedNodes=getAllNodes(grid);while(!!unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(closestNode.isWall)continue;// If the closest node is at a distance of infinity,\n// we must be trapped and should therefore stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbours(closestNode,grid);}}// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(node,grid){var unvisitedNeighbors=getUnvisitedNeighbours(node,grid);var _iterator=_createForOfIteratorHelper(unvisitedNeighbors),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;neighbor.distance=node.distance+1;neighbor.previousNode=node;}}catch(err){_iterator.e(err);}finally{_iterator.f();}}","map":{"version":3,"names":["getAllNodes","sortNodesByDistance","getUnvisitedNeighbours","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","length","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbors","neighbor","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/dijkstra.js"],"sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nimport { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall)\n      continue;\n    \n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity)\n      return visitedNodesInOrder;\n    \n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode)\n      return visitedNodesInOrder;\n    \n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}"],"mappings":"iIAAA;AACA;AACA;AACA;AACA,OAASA,WAAT,CAAsBC,mBAAtB,CAA2CC,sBAA3C,KAAyE,SAAzE,CAEA,MAAO,SAASC,SAAT,CAAkBC,IAAlB,CAAwBC,SAAxB,CAAmCC,UAAnC,CAA+C,CACpD,GAAMC,oBAAmB,CAAG,EAA5B,CACAF,SAAS,CAACG,QAAV,CAAqB,CAArB,CACA,GAAMC,eAAc,CAAGT,WAAW,CAACI,IAAD,CAAlC,CACA,MAAO,CAAC,CAACK,cAAc,CAACC,MAAxB,CAAgC,CAC9BT,mBAAmB,CAACQ,cAAD,CAAnB,CACA,GAAME,YAAW,CAAGF,cAAc,CAACG,KAAf,EAApB,CACA;AACA,GAAID,WAAW,CAACE,MAAhB,CACE,SAEF;AACA;AACA,GAAIF,WAAW,CAACH,QAAZ,GAAyBM,QAA7B,CACE,MAAOP,oBAAP,CAEFI,WAAW,CAACI,SAAZ,CAAwB,IAAxB,CACAR,mBAAmB,CAACS,IAApB,CAAyBL,WAAzB,EACA,GAAIA,WAAW,GAAKL,UAApB,CACE,MAAOC,oBAAP,CAEFU,yBAAyB,CAACN,WAAD,CAAcP,IAAd,CAAzB,CACD,CACF,CAED;AACA;AACA,QAASa,0BAAT,CAAmCC,IAAnC,CAAyCd,IAAzC,CAA+C,CAC7C,GAAMe,mBAAkB,CAAGjB,sBAAsB,CAACgB,IAAD,CAAOd,IAAP,CAAjD,CAD6C,yCAEtBe,kBAFsB,YAE7C,+CAA2C,IAAhCC,SAAgC,aACzCA,QAAQ,CAACZ,QAAT,CAAoBU,IAAI,CAACV,QAAL,CAAgB,CAApC,CACAY,QAAQ,CAACC,YAAT,CAAwBH,IAAxB,CACD,CAL4C,qDAM9C"},"metadata":{},"sourceType":"module"}