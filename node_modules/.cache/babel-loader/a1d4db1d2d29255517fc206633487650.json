{"ast":null,"code":"// Performs BFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = []; // queue to keep track of the visited nodes\n\n  let queue = [];\n  queue.push(startNode);\n\n  while (queue.length) {\n    const currNode = queue.shift(); // if the finsih node is reached then we return the visitedNodes array\n\n    if (currNode === finishNode) return visitedNodesInOrder; // we skip the nodes which are walls, start node or finish node\n\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const {\n        row,\n        col\n      } = currNode;\n      updateUnvisitedNeighbours(row, col, queue, grid, currNode);\n    }\n  }\n} // updates the neighbours,\n// in correspondance to the algorithm \n\nfunction updateUnvisitedNeighbours(row, col, queue, grid, currNode) {\n  let next;\n\n  if (row > 0) {\n    next = grid[row - 1][col];\n\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n\n  if (row < grid.length - 1) {\n    next = grid[row + 1][col];\n\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n\n  if (col > 0) {\n    next = grid[row][col - 1];\n\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    next = grid[row][col + 1];\n\n    if (!next.isVisited) {\n      queue.push(next);\n      next.previousNode = currNode;\n    }\n  }\n}","map":{"version":3,"names":["bfs","grid","startNode","finishNode","visitedNodesInOrder","queue","push","length","currNode","shift","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/bfs.js"],"sourcesContent":["// Performs BFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  // queue to keep track of the visited nodes\n  let queue = [];\n  queue.push(startNode);\n  while (queue.length) {\n    const currNode = queue.shift();\n    // if the finsih node is reached then we return the visitedNodes array\n    if (currNode === finishNode)\n      return visitedNodesInOrder;\n    \n    // we skip the nodes which are walls, start node or finish node\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const { row, col } = currNode;\n      updateUnvisitedNeighbours(row, col, queue, grid,currNode);\n    }\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(row,col,queue,grid,currNode) {\n      let next;\n      if (row > 0) {\n        next = grid[row - 1][col];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (row < grid.length - 1) {\n        next = grid[row + 1][col];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (col > 0) {\n        next = grid[row][col - 1];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n      if (col < grid[0].length - 1) {\n        next = grid[row][col + 1];\n        if (!next.isVisited) {\n          queue.push(next);\n          next.previousNode = currNode;\n        }\n      }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;EAC/C,MAAMC,mBAAmB,GAAG,EAA5B,CAD+C,CAE/C;;EACA,IAAIC,KAAK,GAAG,EAAZ;EACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX;;EACA,OAAOG,KAAK,CAACE,MAAb,EAAqB;IACnB,MAAMC,QAAQ,GAAGH,KAAK,CAACI,KAAN,EAAjB,CADmB,CAEnB;;IACA,IAAID,QAAQ,KAAKL,UAAjB,EACE,OAAOC,mBAAP,CAJiB,CAMnB;;IACA,IAAI,CAACI,QAAQ,CAACE,MAAV,KAAqBF,QAAQ,CAACG,OAAT,IAAoB,CAACH,QAAQ,CAACI,SAAnD,CAAJ,EAAmE;MACjEJ,QAAQ,CAACI,SAAT,GAAqB,IAArB;MACAR,mBAAmB,CAACE,IAApB,CAAyBE,QAAzB;MACA,MAAM;QAAEK,GAAF;QAAOC;MAAP,IAAeN,QAArB;MACAO,yBAAyB,CAACF,GAAD,EAAMC,GAAN,EAAWT,KAAX,EAAkBJ,IAAlB,EAAuBO,QAAvB,CAAzB;IACD;EACF;AACF,C,CAED;AACA;;AACA,SAASO,yBAAT,CAAmCF,GAAnC,EAAuCC,GAAvC,EAA2CT,KAA3C,EAAiDJ,IAAjD,EAAsDO,QAAtD,EAAgE;EAC1D,IAAIQ,IAAJ;;EACA,IAAIH,GAAG,GAAG,CAAV,EAAa;IACXG,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX;MACAA,IAAI,CAACC,YAAL,GAAoBT,QAApB;IACD;EACF;;EACD,IAAIK,GAAG,GAAGZ,IAAI,CAACM,MAAL,GAAc,CAAxB,EAA2B;IACzBS,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX;MACAA,IAAI,CAACC,YAAL,GAAoBT,QAApB;IACD;EACF;;EACD,IAAIM,GAAG,GAAG,CAAV,EAAa;IACXE,IAAI,GAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX;MACAA,IAAI,CAACC,YAAL,GAAoBT,QAApB;IACD;EACF;;EACD,IAAIM,GAAG,GAAGb,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA3B,EAA8B;IAC5BS,IAAI,GAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBP,KAAK,CAACC,IAAN,CAAWU,IAAX;MACAA,IAAI,CAACC,YAAL,GAAoBT,QAApB;IACD;EACF;AACN"},"metadata":{},"sourceType":"module"}