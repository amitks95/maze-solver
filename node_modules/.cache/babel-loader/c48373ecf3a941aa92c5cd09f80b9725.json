{"ast":null,"code":"var _jsxFileName = \"D:\\\\maze-solver-main\\\\src\\\\components\\\\PathVisualizer\\\\PathVisualizer.js\";\nimport React, { Component } from 'react';\nimport \"./PathVisualizer.scss\";\nimport Node from \"../Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\nimport Footer from \"../Footer/Footer\";\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\nimport Legend from '../Legend/Legend'; // constants - initial coordinates for start and finish nodes \n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nclass PathVisualizer extends Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      isPathNotFound: false,\n      visitedNodes: 0,\n      shortestNodes: 0,\n      tooltipOpen: false,\n      isVisualizing: false,\n      mainIsPressed: \"\",\n      startNode_Pos: [START_NODE_ROW, START_NODE_COL],\n      finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL]\n    };\n\n    this.toggle = () => {\n      this.setState({\n        tooltipOpen: !this.state.tooltipOpen\n      });\n    };\n\n    this.visualizeDijkstra = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n            start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n            finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n\n      try {\n        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        if (nodesInShortestPathOrder.length === 1) throw \"not possible\";\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      } //this.setState({ isVisualizing: false });\n\n    };\n\n    this.visualizeDFS = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n            start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n            finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n\n      try {\n        const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        console.log(error);\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n\n    this.visualizeBFS = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n            start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n            finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n\n      try {\n        const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n\n    this.visualizeAstar = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n            start_Y = startNode_Pos[1];\n      const startNode = grid[start_X][start_Y];\n      const finish_X = finishNode_Pos[0],\n            finish_Y = finishNode_Pos[1];\n      const finishNode = grid[finish_X][finish_Y];\n\n      try {\n        const visitedNodesInOrder = astar(grid, startNode, finishNode);\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n        if (nodesInShortestPathOrder.length === 1) {\n          throw \"not possible\";\n        }\n\n        this.setState({\n          shortestNodes: nodesInShortestPathOrder.length,\n          visitedNodes: visitedNodesInOrder.length\n        });\n        animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n      } catch (error) {\n        this.setState({\n          isPathNotFound: true,\n          isVisualizing: true\n        });\n        setTimeout(() => {\n          this.setState({\n            isPathNotFound: false,\n            isVisualizing: false\n          });\n        }, 3000);\n      }\n    };\n\n    this.clearGrid = () => {\n      if (this.state.isVisualizing) return;\n      const {\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const start_X = startNode_Pos[0],\n            start_Y = startNode_Pos[1];\n      const finish_X = finishNode_Pos[0],\n            finish_Y = finishNode_Pos[1];\n\n      for (let row = 0; row < this.state.grid.length; row++) {\n        for (let col = 0; col < this.state.grid[0].length; col++) {\n          if (!(row === start_X && col === start_Y || row === finish_X && col === finish_Y)) {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n\n      const newGrid = getInitialGrid(startNode_Pos, finishNode_Pos);\n      this.setState({\n        grid: newGrid,\n        visitedNodes: 0,\n        shortestNodes: 0\n      });\n    };\n\n    this.clearPath = () => {\n      if (this.state.isVisualizing) return;\n\n      for (let row = 0; row < this.state.grid.length; row++) {\n        for (let col = 0; col < this.state.grid[0].length; col++) {\n          if (document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\" || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\n            document.getElementById(`node-${row}-${col}`).className = \"node\";\n          }\n        }\n      }\n\n      const newGrid = getGridWithoutPath(this.state.grid);\n      this.setState({\n        grid: newGrid,\n        visitedNodes: 0,\n        shortestNodes: 0\n      });\n    };\n\n    this.generateRecursiveDivisionMaze = () => {\n      if (this.state.isVisualizing) return;\n      this.setState({\n        isVisualizing: true\n      });\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n      const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      this.animateWalls(walls, grid);\n    };\n\n    this.generateRandomMaze = () => {\n      if (this.state.isVisualizing) return;\n      this.setState({\n        isVisualizing: true\n      });\n      const {\n        grid,\n        startNode_Pos,\n        finishNode_Pos\n      } = this.state;\n      const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n      const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n      const walls = randomMaze(grid, startNode, finishNode);\n      this.animateWalls(walls, grid);\n    };\n\n    this.animateWalls = (walls, grid) => {\n      for (let i = 0; i <= walls.length; i++) {\n        if (i === walls.length) {\n          setTimeout(() => {\n            const newGrid = getNewGridWithMaze(this.state.grid, walls);\n            this.setState({\n              grid: newGrid,\n              isVisualizing: false\n            });\n          }, 10 * i);\n          return;\n        }\n\n        setTimeout(() => {\n          const wall = walls[i];\n          const node = grid[wall[0]][wall[1]];\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\n        }, 10 * i);\n      }\n    };\n\n    this.setVisualization = () => {\n      this.setState({\n        isVisualizing: !this.state.isVisualizing\n      });\n    };\n\n    this.handleClick = () => {\n      setVisualizationState(this);\n    };\n  }\n\n  // creates the grid when the component is mounted\n  componentDidMount() {\n    const {\n      startNode_Pos,\n      finishNode_Pos\n    } = this.state;\n    let grid = getInitialGrid(startNode_Pos, finishNode_Pos);\n    this.setState({\n      grid\n    });\n  } // tool tip toggle\n\n\n  /*-------------------------------------------------------------mouse events--------------------------------------------------------------- */\n  // handling mouse events to set up walls\n  handleMouseDown(row, col) {\n    const {\n      grid,\n      mainIsPressed\n    } = this.state;\n    const node = grid[row][col];\n\n    if (node.isStart === true && node.isFinish === false) {\n      this.setState({\n        mainIsPressed: \"start\"\n      });\n      node.isStart = false;\n    }\n\n    if (node.isFinish === true && node.isStart === false) {\n      this.setState({\n        mainIsPressed: \"finish\"\n      });\n      node.isFinish = false;\n    }\n\n    if (mainIsPressed === \"\") {\n      const newGrid = gridWithWallToggled(grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    const {\n      grid,\n      mouseIsPressed,\n      mainIsPressed\n    } = this.state;\n\n    if (mainIsPressed === \"start\") {\n      const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n      this.setState({\n        grid: newGrid\n      });\n    }\n\n    if (mainIsPressed === \"finish\") {\n      const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n      this.setState({\n        grid: newGrid\n      });\n    }\n\n    if (mouseIsPressed && mainIsPressed === \"\") {\n      const newGrid = gridWithWallToggled(grid, row, col);\n      this.setState({\n        grid: newGrid,\n        mouseIsPressed: true\n      });\n    }\n  }\n\n  handleMouseUp(row, col) {\n    const {\n      mainIsPressed,\n      grid\n    } = this.state;\n\n    if (mainIsPressed === \"start\") {\n      this.setState({\n        mainIsPressed: \"\"\n      });\n      const startNode_Pos = [row, col];\n      const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n      this.setState({\n        mainIsPressed: \"\",\n        startNode_Pos,\n        grid: newGrid\n      });\n    }\n\n    if (mainIsPressed === \"finish\") {\n      const finishNode_Pos = [row, col];\n      const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n      this.setState({\n        mainIsPressed: \"\",\n        finishNode_Pos,\n        grid: newGrid\n      });\n    }\n\n    this.setState({\n      mouseIsPressed: false\n    });\n  }\n\n  handleMouseLeave(row, col) {\n    const {\n      grid,\n      mainIsPressed\n    } = this.state;\n    if (mainIsPressed === \"\") return;\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n\n    if (mainIsPressed === \"start\") {\n      const newNode = { ...node,\n        isStart: false,\n        isWall: false\n      };\n      newGrid[row][col] = newNode;\n    }\n\n    if (mainIsPressed === \"finish\") {\n      const newNode = { ...node,\n        isFinish: false,\n        isWall: false\n      };\n      newGrid[row][col] = newNode;\n    }\n\n    this.setState({\n      grid: newGrid\n    });\n  }\n  /*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\n  // dijkstra\n\n\n  render() {\n    const {\n      grid,\n      mouseIsPressed,\n      visitedNodes,\n      shortestNodes\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(TooltipExampleMulti, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 321,\n        columnNumber: 17\n      }, this), this.state.isPathNotFound ? /*#__PURE__*/_jsxDEV(ErrorModal, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 46\n      }, this) : null, /*#__PURE__*/_jsxDEV(AppNavbar, {\n        handleDijkstra: this.visualizeDijkstra,\n        handleDFS: this.visualizeDFS,\n        handleBFS: this.visualizeBFS,\n        handleAstar: this.visualizeAstar,\n        handleClearPath: this.clearPath,\n        handleClearGrid: this.clearGrid,\n        handleMaze: this.generateRecursiveDivisionMaze,\n        handleRandomMaze: this.generateRandomMaze,\n        handleVisualization: this.setVisualization,\n        visitedNodes: visitedNodes,\n        shortestNodes: shortestNodes\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Legend, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 337,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid\",\n        children: grid.map((row, rowIdx) => {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: row.map((node, nodeIdx) => {\n              const {\n                row,\n                col,\n                isStart,\n                isFinish,\n                isWall\n              } = node;\n              return /*#__PURE__*/_jsxDEV(Node, {\n                row: row,\n                col: col,\n                isStart: isStart,\n                isFinish: isFinish,\n                isWall: isWall,\n                mouseIsPressed: mouseIsPressed,\n                onMouseDown: (row, col) => this.handleMouseDown(row, col),\n                onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n                onMouseUp: (row, col) => this.handleMouseUp(row, col),\n                onMouseLeave: (row, col) => this.handleMouseLeave(row, col)\n              }, nodeIdx, false, {\n                fileName: _jsxFileName,\n                lineNumber: 346,\n                columnNumber: 41\n              }, this);\n            })\n          }, rowIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 342,\n            columnNumber: 29\n          }, this);\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 365,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true);\n  }\n\n}\n\nexport default PathVisualizer;\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\n// creating the initial grid, calls the createNode() function\n// to initialise the node with initial properties\n\nconst getInitialGrid = (startNode_Pos, finishNode_Pos) => {\n  let grid = []; // const startNode_Pos = [10, 15];\n  // const finishNode_Pos = [10, 35];\n\n  for (let row = 0; row < 20; row++) {\n    const currRow = [];\n\n    for (let col = 0; col < 40; col++) {\n      //  previously I had it as 20*50\n      currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\n    }\n\n    grid.push(currRow);\n  }\n\n  return grid;\n}; // initialising the node with its initial properties\n\n\nconst createNode = (row, col, startNode, finishNode) => {\n  let start_x = startNode[0];\n  let start_y = startNode[1];\n  let finish_x = finishNode[0];\n  let finish_y = finishNode[1];\n  return {\n    row,\n    col,\n    isStart: row === start_x && col === start_y,\n    isFinish: row === finish_x && col === finish_y,\n    isWall: false,\n    distance: Infinity,\n    isVisited: false,\n    previousNode: null,\n    distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\n  };\n}; // updating the grid, when the walls are tiggered\n\n\nconst gridWithWallToggled = (grid, row, col) => {\n  let newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst gridDynamicNodes = (grid, row, col, pos) => {\n  console.log(`start node is currently at: row: ${row} col: ${col}`);\n  let newGrid = grid.slice();\n  const node = newGrid[row][col];\n\n  if (pos === \"start\") {\n    const newNode = { ...node,\n      isStart: true\n    };\n    newGrid[row][col] = newNode;\n  }\n\n  if (pos === \"finish\") {\n    const newNode = { ...node,\n      isFinish: true\n    };\n    newGrid[row][col] = newNode;\n  }\n\n  return newGrid;\n}; // updating the grid, resetting the features except for the walls\n\n\nconst getGridWithoutPath = grid => {\n  let newGrid = grid.slice();\n\n  for (let row of grid) {\n    for (let node of row) {\n      let newNode = { ...node,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  }\n\n  return newGrid;\n};\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = { ...node,\n      isWall: true\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n\n  return newGrid;\n};","map":{"version":3,"names":["React","Component","Node","dijkstra","getNodesInShortestPathOrder","dfs","bfs","astar","animatePath","animateWalls","setVisualizationState","recursiveDivisionMaze","randomMaze","AppNavbar","ErrorModal","Footer","TooltipExampleMulti","Legend","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathVisualizer","state","grid","mouseIsPressed","isPathNotFound","visitedNodes","shortestNodes","tooltipOpen","isVisualizing","mainIsPressed","startNode_Pos","finishNode_Pos","toggle","setState","visualizeDijkstra","start_X","start_Y","startNode","finish_X","finish_Y","finishNode","visitedNodesInOrder","nodesInShortestPathOrder","length","error","setTimeout","visualizeDFS","console","log","visualizeBFS","visualizeAstar","clearGrid","row","col","document","getElementById","className","newGrid","getInitialGrid","clearPath","getGridWithoutPath","generateRecursiveDivisionMaze","walls","generateRandomMaze","i","getNewGridWithMaze","wall","node","setVisualization","handleClick","componentDidMount","handleMouseDown","isStart","isFinish","gridWithWallToggled","handleMouseEnter","gridDynamicNodes","handleMouseUp","handleMouseLeave","slice","newNode","isWall","render","map","rowIdx","nodeIdx","currRow","push","createNode","start_x","start_y","finish_x","finish_y","distance","Infinity","isVisited","previousNode","distanceToFinishNode","Math","abs","pos"],"sources":["D:/maze-solver-main/src/components/PathVisualizer/PathVisualizer.js"],"sourcesContent":["import React, { Component } from 'react';\nimport \"./PathVisualizer.scss\";\nimport Node from \"../Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\nimport Footer from \"../Footer/Footer\";\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\nimport Legend from '../Legend/Legend';\n\n// constants - initial coordinates for start and finish nodes \nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nclass PathVisualizer extends Component {\n    state = {\n        grid: [],\n        mouseIsPressed: false,\n        isPathNotFound: false,\n        visitedNodes: 0,\n        shortestNodes: 0,\n        tooltipOpen: false,\n        isVisualizing: false,\n        mainIsPressed: \"\",\n        startNode_Pos: [START_NODE_ROW, START_NODE_COL],\n        finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL],\n    }\n\n    // creates the grid when the component is mounted\n    componentDidMount() {\n        const { startNode_Pos, finishNode_Pos } = this.state;\n        let grid = getInitialGrid(startNode_Pos,finishNode_Pos);\n        this.setState({ grid });   \n    }\n\n    // tool tip toggle\n    toggle = () => {\n        this.setState({ tooltipOpen: !this.state.tooltipOpen });\n    }\n\n/*-------------------------------------------------------------mouse events--------------------------------------------------------------- */\n    // handling mouse events to set up walls\n\n    handleMouseDown(row, col) {\n        const { grid, mainIsPressed } = this.state;\n        const node = grid[row][col];\n        if (node.isStart === true && node.isFinish === false) {\n            this.setState({ mainIsPressed: \"start\" });\n            node.isStart = false;\n        }\n        if (node.isFinish === true && node.isStart === false) {\n            this.setState({ mainIsPressed: \"finish\" });\n            node.isFinish = false;\n        }\n        if (mainIsPressed === \"\") {\n            const newGrid = gridWithWallToggled(grid, row, col);\n            this.setState({ grid: newGrid, mouseIsPressed: true });\n        }\n    }\n    \n    handleMouseEnter(row, col) {\n        const { grid, mouseIsPressed, mainIsPressed } = this.state;\n        if (mainIsPressed === \"start\") {\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n            this.setState({ grid: newGrid });\n        }\n        if (mainIsPressed === \"finish\") {\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n            this.setState({ grid: newGrid });\n        }\n        if (mouseIsPressed && mainIsPressed === \"\") {\n            const newGrid = gridWithWallToggled(grid, row, col);\n            this.setState({ grid: newGrid, mouseIsPressed: true });\n        }\n    }\n\n    handleMouseUp(row,col) {\n        const { mainIsPressed, grid } = this.state;\n        if (mainIsPressed === \"start\") {\n            this.setState({ mainIsPressed: \"\" });\n            const startNode_Pos = [row, col];\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n            this.setState({ mainIsPressed: \"\", startNode_Pos, grid: newGrid });\n        }\n        if (mainIsPressed === \"finish\") {\n            const finishNode_Pos = [row, col];\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n            this.setState({ mainIsPressed: \"\", finishNode_Pos, grid: newGrid });\n        }\n        this.setState({ mouseIsPressed: false });\n    }\n\n    handleMouseLeave(row, col) {\n        const { grid, mainIsPressed } = this.state;\n        if (mainIsPressed === \"\")\n            return;\n        let newGrid = grid.slice();\n        const node = newGrid[row][col];\n        if (mainIsPressed === \"start\") {\n            const newNode = {\n                ...node,\n                isStart: false,\n                isWall: false\n            }\n            newGrid[row][col] = newNode;\n        }\n        if (mainIsPressed === \"finish\") {\n            const newNode = {\n                ...node,\n                isFinish: false,\n                isWall: false\n            }\n            newGrid[row][col] = newNode;\n        }\n        this.setState({ grid: newGrid });\n    }\n\n/*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\n    // dijkstra\n    visualizeDijkstra = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            if (nodesInShortestPathOrder.length === 1)\n                throw \"not possible\";\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n        //this.setState({ isVisualizing: false });\n    }\n\n    // dfs\n    visualizeDFS = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            console.log(error)\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n    // bfs\n    visualizeBFS = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n    // astar\n    visualizeAstar = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = astar(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            if (nodesInShortestPathOrder.length === 1) {\n                throw \"not possible\";\n            }\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n/*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\n    clearGrid = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        for (let row = 0; row < this.state.grid.length; row++) {\n            for (let col = 0; col < this.state.grid[0].length; col++) {\n                if (!((row === start_X && col === start_Y) || (row === finish_X && col === finish_Y))) {\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\n                }\n            }\n        }\n        const newGrid = getInitialGrid(startNode_Pos,finishNode_Pos);\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\n    }\n\n    clearPath = () => {\n        if (this.state.isVisualizing)\n            return;\n        for (let row = 0; row < this.state.grid.length; row++) {\n            for (let col = 0; col < this.state.grid[0].length; col++) {\n                if ((document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\n                }\n            }\n        }\n        const newGrid = getGridWithoutPath(this.state.grid);\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\n    }\n\n/*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\n    generateRecursiveDivisionMaze = () => {\n        if (this.state.isVisualizing)\n            return;\n        this.setState({ isVisualizing: true });\n        const { grid, startNode_Pos,finishNode_Pos } = this.state;\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n        const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n        this.animateWalls(walls, grid);\n    }\n\n    generateRandomMaze = () => {\n        if (this.state.isVisualizing)\n            return;\n        this.setState({ isVisualizing: true });\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n        const walls = randomMaze(grid, startNode, finishNode);\n        this.animateWalls(walls, grid);\n    }\n\n    animateWalls = (walls, grid) => {\n        for (let i = 0; i <= walls.length; i++) {\n            if (i === walls.length) {\n                setTimeout(() => {\n                    const newGrid = getNewGridWithMaze(this.state.grid, walls);\n                    this.setState({ grid: newGrid, isVisualizing: false });\n                }, 10 * i);\n                return ;\n            }\n            setTimeout(() => {\n                const wall = walls[i];\n                const node = grid[wall[0]][wall[1]];\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\n            }, 10 * i);\n        }\n    }\n\n/*------------------------------------------------------------------------------------------------------------------------------*/\n\n    // sets the stae to visualizing, to prevent any other func from executing during the visualization\n    setVisualization = () => {\n        this.setState({\n            isVisualizing: !this.state.isVisualizing\n        });\n    }\n\n    // same as the previous func, but this one to set the state outside of this component, in algorithms visualizing components\n    handleClick = () => {\n        setVisualizationState(this);\n    }\n\n    render() {\n        const { grid, mouseIsPressed, visitedNodes, shortestNodes } = this.state;\n\n        return (\n            <>\n                <TooltipExampleMulti />\n                {this.state.isPathNotFound ? <ErrorModal /> : null }\n                <AppNavbar\n                    handleDijkstra={this.visualizeDijkstra}\n                    handleDFS={this.visualizeDFS}\n                    handleBFS={this.visualizeBFS}\n                    handleAstar={this.visualizeAstar}\n                    handleClearPath={this.clearPath}\n                    handleClearGrid={this.clearGrid}\n                    handleMaze={this.generateRecursiveDivisionMaze}\n                    handleRandomMaze={this.generateRandomMaze}\n                    handleVisualization={this.setVisualization}\n                    visitedNodes={visitedNodes}\n                    shortestNodes={shortestNodes}\n                />\n\n                <Legend />\n           \n                <div className=\"grid\">\n                    {grid.map((row, rowIdx) => {\n                        return (\n                            <div key={rowIdx}>\n                                {row.map((node, nodeIdx) => {\n                                    const { row, col, isStart, isFinish, isWall } = node;\n                                    return (\n                                        <Node\n                                            key={nodeIdx}\n                                            row={row}\n                                            col={col}\n                                            isStart={isStart}\n                                            isFinish={isFinish}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                            onMouseUp={(row,col) => this.handleMouseUp(row,col)}\n                                            onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\n                                        />\n                                    )\n                                })}\n                            </div>\n                        )\n                    })}\n                </div>\n                <Footer />\n            </>\n         );\n    }\n}\n\nexport default PathVisualizer;\n\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\n\n// creating the initial grid, calls the createNode() function\n// to initialise the node with initial properties\nconst getInitialGrid = (startNode_Pos,finishNode_Pos) => {\n    let grid = [];\n    // const startNode_Pos = [10, 15];\n    // const finishNode_Pos = [10, 35];\n    for (let row = 0; row < 20; row++) {\n        const currRow = [];\n        for (let col = 0; col < 40; col++) { //  previously I had it as 20*50\n            currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\n        }\n        grid.push(currRow);\n    }\n    return grid;\n}\n\n// initialising the node with its initial properties\nconst createNode = (row, col, startNode, finishNode) => {\n    let start_x = startNode[0];\n    let start_y = startNode[1];\n    let finish_x = finishNode[0];\n    let finish_y = finishNode[1];\n\n    return {\n        row,\n        col,\n        isStart: row === start_x && col === start_y,\n        isFinish: row === finish_x && col === finish_y,\n        isWall: false,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\n    }\n}\n\n// updating the grid, when the walls are tiggered\nconst gridWithWallToggled = (grid, row, col) => {\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isWall: !node.isWall\n    }\n    newGrid[row][col] = newNode;\n    return newGrid;\n}\n\n\nconst gridDynamicNodes = (grid, row, col, pos) => {\n    console.log(`start node is currently at: row: ${row} col: ${col}`);\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (pos === \"start\") {\n        const newNode = {\n            ...node,\n            isStart: true\n        }\n        newGrid[row][col] = newNode;\n    }\n    if (pos === \"finish\") {\n        const newNode = {\n            ...node,\n            isFinish: true\n        }\n        newGrid[row][col] = newNode;\n    }\n    return newGrid;\n}\n\n// updating the grid, resetting the features except for the walls\nconst getGridWithoutPath = (grid) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n        for (let node of row) {\n            let newNode = {\n                ...node,\n                distance: Infinity,\n                isVisited: false,\n                previousNode: null,\n                distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\n            };\n            newGrid[node.row][node.col] = newNode;\n        }\n    }\n    return newGrid;\n}\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}