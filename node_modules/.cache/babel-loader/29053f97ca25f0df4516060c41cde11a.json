{"ast":null,"code":"// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nimport { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // If we encounter a wall, we skip it.\n\n    if (closestNode.isWall) continue; // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n} // updates the neighbours,\n// in correspondance to the algorithm \n\nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}","map":{"version":3,"names":["getAllNodes","sortNodesByDistance","getUnvisitedNeighbours","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","length","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbours","node","unvisitedNeighbors","neighbor","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/dijkstra.js"],"sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nimport { getAllNodes, sortNodesByDistance, getUnvisitedNeighbours } from \"./index\";\n\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall)\n      continue;\n    \n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity)\n      return visitedNodesInOrder;\n    \n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode)\n      return visitedNodesInOrder;\n    \n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction updateUnvisitedNeighbours(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbours(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,WAAT,EAAsBC,mBAAtB,EAA2CC,sBAA3C,QAAyE,SAAzE;AAEA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;EACpD,MAAMC,mBAAmB,GAAG,EAA5B;EACAF,SAAS,CAACG,QAAV,GAAqB,CAArB;EACA,MAAMC,cAAc,GAAGT,WAAW,CAACI,IAAD,CAAlC;;EACA,OAAO,CAAC,CAACK,cAAc,CAACC,MAAxB,EAAgC;IAC9BT,mBAAmB,CAACQ,cAAD,CAAnB;IACA,MAAME,WAAW,GAAGF,cAAc,CAACG,KAAf,EAApB,CAF8B,CAG9B;;IACA,IAAID,WAAW,CAACE,MAAhB,EACE,SAL4B,CAO9B;IACA;;IACA,IAAIF,WAAW,CAACH,QAAZ,KAAyBM,QAA7B,EACE,OAAOP,mBAAP;IAEFI,WAAW,CAACI,SAAZ,GAAwB,IAAxB;IACAR,mBAAmB,CAACS,IAApB,CAAyBL,WAAzB;IACA,IAAIA,WAAW,KAAKL,UAApB,EACE,OAAOC,mBAAP;IAEFU,yBAAyB,CAACN,WAAD,EAAcP,IAAd,CAAzB;EACD;AACF,C,CAED;AACA;;AACA,SAASa,yBAAT,CAAmCC,IAAnC,EAAyCd,IAAzC,EAA+C;EAC7C,MAAMe,kBAAkB,GAAGjB,sBAAsB,CAACgB,IAAD,EAAOd,IAAP,CAAjD;;EACA,KAAK,MAAMgB,QAAX,IAAuBD,kBAAvB,EAA2C;IACzCC,QAAQ,CAACZ,QAAT,GAAoBU,IAAI,CAACV,QAAL,GAAgB,CAApC;IACAY,QAAQ,CAACC,YAAT,GAAwBH,IAAxB;EACD;AACF"},"metadata":{},"sourceType":"module"}