{"ast":null,"code":"// Performs DFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = []; // stack to keep track of the visited nodes\n\n  const stack = [];\n  stack.push(startNode);\n\n  while (stack.length) {\n    const currNode = stack.pop(); // if the finsih node is reached then we return the visitedNodes array\n\n    if (currNode === finishNode) return visitedNodesInOrder; // we skip the nodes which are walls, start node or finish node\n\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const {\n        row,\n        col\n      } = currNode;\n      updateUnvisitedNeighbours(row, col, stack, grid, currNode);\n    }\n  }\n} // updates the neighbours,\n// in correspondance to the algorithm \n\nfunction updateUnvisitedNeighbours(row, col, stack, grid, currNode) {\n  let next;\n\n  if (row > 0) {\n    next = grid[row - 1][col];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    next = grid[row + 1][col];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    next = grid[row][col + 1];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n\n  if (col > 0) {\n    next = grid[row][col - 1];\n\n    if (!next.isVisited) {\n      next.previousNode = currNode;\n      stack.push(next);\n    }\n  }\n}","map":{"version":3,"names":["dfs","grid","startNode","finishNode","visitedNodesInOrder","stack","push","length","currNode","pop","isWall","isStart","isVisited","row","col","updateUnvisitedNeighbours","next","previousNode"],"sources":["D:/maze-solver-main/src/algorithms/dfs.js"],"sourcesContent":["// Performs DFS algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  // stack to keep track of the visited nodes\n  const stack = []; \n  stack.push(startNode);\n  while (stack.length) {\n    const currNode = stack.pop();\n    // if the finsih node is reached then we return the visitedNodes array\n    if (currNode === finishNode) \n      return visitedNodesInOrder;\n\n    // we skip the nodes which are walls, start node or finish node\n    if (!currNode.isWall && (currNode.isStart || !currNode.isVisited)) {\n      currNode.isVisited = true;\n      visitedNodesInOrder.push(currNode);\n      const { row, col } = currNode;\n      updateUnvisitedNeighbours(row, col, stack, grid,currNode);\n    }\n  }\n}\n\n// updates the neighbours,\n// in correspondance to the algorithm \nfunction  updateUnvisitedNeighbours(row, col, stack, grid,currNode) {\n      let next;\n      if (row > 0) {\n        next = grid[row - 1][col];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (row < grid.length - 1) {\n        next = grid[row + 1][col];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        next = grid[row][col + 1];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n      if (col > 0) {\n        next = grid[row][col - 1];\n        if (!next.isVisited) {\n          next.previousNode = currNode;\n          stack.push(next);\n        }\n      }\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;EAC/C,MAAMC,mBAAmB,GAAG,EAA5B,CAD+C,CAE/C;;EACA,MAAMC,KAAK,GAAG,EAAd;EACAA,KAAK,CAACC,IAAN,CAAWJ,SAAX;;EACA,OAAOG,KAAK,CAACE,MAAb,EAAqB;IACnB,MAAMC,QAAQ,GAAGH,KAAK,CAACI,GAAN,EAAjB,CADmB,CAEnB;;IACA,IAAID,QAAQ,KAAKL,UAAjB,EACE,OAAOC,mBAAP,CAJiB,CAMnB;;IACA,IAAI,CAACI,QAAQ,CAACE,MAAV,KAAqBF,QAAQ,CAACG,OAAT,IAAoB,CAACH,QAAQ,CAACI,SAAnD,CAAJ,EAAmE;MACjEJ,QAAQ,CAACI,SAAT,GAAqB,IAArB;MACAR,mBAAmB,CAACE,IAApB,CAAyBE,QAAzB;MACA,MAAM;QAAEK,GAAF;QAAOC;MAAP,IAAeN,QAArB;MACAO,yBAAyB,CAACF,GAAD,EAAMC,GAAN,EAAWT,KAAX,EAAkBJ,IAAlB,EAAuBO,QAAvB,CAAzB;IACD;EACF;AACF,C,CAED;AACA;;AACA,SAAUO,yBAAV,CAAoCF,GAApC,EAAyCC,GAAzC,EAA8CT,KAA9C,EAAqDJ,IAArD,EAA0DO,QAA1D,EAAoE;EAC9D,IAAIQ,IAAJ;;EACA,IAAIH,GAAG,GAAG,CAAV,EAAa;IACXG,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBI,IAAI,CAACC,YAAL,GAAoBT,QAApB;MACAH,KAAK,CAACC,IAAN,CAAWU,IAAX;IACD;EACF;;EACD,IAAIH,GAAG,GAAGZ,IAAI,CAACM,MAAL,GAAc,CAAxB,EAA2B;IACzBS,IAAI,GAAGf,IAAI,CAACY,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBI,IAAI,CAACC,YAAL,GAAoBT,QAApB;MACAH,KAAK,CAACC,IAAN,CAAWU,IAAX;IACD;EACF;;EACD,IAAIF,GAAG,GAAGb,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA3B,EAA8B;IAC5BS,IAAI,GAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBI,IAAI,CAACC,YAAL,GAAoBT,QAApB;MACAH,KAAK,CAACC,IAAN,CAAWU,IAAX;IACD;EACF;;EACD,IAAIF,GAAG,GAAG,CAAV,EAAa;IACXE,IAAI,GAAGf,IAAI,CAACY,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAP;;IACA,IAAI,CAACE,IAAI,CAACJ,SAAV,EAAqB;MACnBI,IAAI,CAACC,YAAL,GAAoBT,QAApB;MACAH,KAAK,CAACC,IAAN,CAAWU,IAAX;IACD;EACF;AACN"},"metadata":{},"sourceType":"module"}